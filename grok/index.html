<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>File Analysis Tool</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/exif-js/2.3.0/exif.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
</head>
<body class="bg-gray-100 p-4">
  <div class="max-w-4xl mx-auto bg-white p-6 rounded-lg shadow-md">
    <h1 class="text-2xl font-bold mb-4">File Analysis Tool</h1>
    <input type="file" id="fileInput" class="mb-4 p-2 border rounded" accept=".txt,.jpg,.jpeg,.png,.docx,.mp3,.pdf,.mp4">
    <p id="error" class="text-red-500 hidden"></p>

    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
      <!-- Graphical View and Hex Viewer -->
      <div>
        <h2 class="text-xl font-semibold mb-2">Graphical View</h2>
        <canvas id="fileCanvas" class="w-full border rounded mb-2"></canvas>
        <div class="text-sm mb-2">
          <p><span class="inline-block w-4 h-4 bg-yellow-200"></span> Metadata (Potentially Sensitive)</p>
          <p><span class="inline-block w-4 h-4 bg-blue-200"></span> File System/Headers</p>
          <p><span class="inline-block w-4 h-4 bg-green-200"></span> Content</p>
          <p><span class="inline-block w-4 h-4 bg-gray-200"></span> Unknown/Other</p>
        </div>
        <h2 class="text-xl font-semibold mb-2">Hex Viewer (Sensitive Data Highlighted)</h2>
        <div id="hexViewer" class="w-full h-64 p-2 border rounded font-mono text-sm overflow-auto" contenteditable="true"></div>
        <button id="saveHex" class="mt-2 bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Save Hex Changes</button>
        <div class="mt-2">
          <label for="scrubber" class="block text-sm font-medium">Scrub through file:</label>
          <input type="range" id="scrubber" min="0" max="0" value="0" class="w-full">
          <p id="scrubberPos" class="text-sm">Position: 0</p>
        </div>
      </div>

      <!-- Metadata and Binary Output -->
      <div>
        <h2 class="text-xl font-semibold mb-2">Metadata</h2>
        <pre id="metadata" class="bg-gray-50 p-2 border rounded h-32 overflow-auto text-sm"></pre>
        <h2 class="text-xl font-semibold mt-4 mb-2">Binary Sample</h2>
        <pre id="binaryOutput" class="bg-gray-50 p-2 border rounded h-32 overflow-auto text-sm"></pre>
      </div>
    </div>

    <!-- Encryption Section -->
    <div class="mt-6">
      <h2 class="text-xl font-semibold mb-2">Encryption Analysis</h2>
      <div class="flex gap-4 mb-2">
        <select id="cipherSelect" class="p-2 border rounded">
          <option value="caesar">Caesar Cipher</option>
          <option value="aes">AES-256</option>
          <option value="xor">XOR Cipher</option>
        </select>
        <input type="text" id="cipherKey" class="p-2 border rounded" placeholder="Enter key (e.g., 3 for Caesar, password for AES)">
        <button id="encryptBtn" class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600">Encrypt</button>
        <button id="decryptBtn" class="bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600">Decrypt</button>
      </div>
      <textarea id="encryptedOutput" class="w-full h-32 p-2 border rounded font-mono text-sm" placeholder="Encrypted hex will appear here..."></textarea>
    </div>
  </div>

  <script>
    const fileInput = document.getElementById('fileInput');
    const fileCanvas = document.getElementById('fileCanvas');
    const hexViewer = document.getElementById('hexViewer');
    const saveHex = document.getElementById('saveHex');
    const metadata = document.getElementById('metadata');
    const binaryOutput = document.getElementById('binaryOutput');
    const error = document.getElementById('error');
    const scrubber = document.getElementById('scrubber');
    const scrubberPos = document.getElementById('scrubberPos');
    const cipherSelect = document.getElementById('cipherSelect');
    const cipherKey = document.getElementById('cipherKey');
    const encryptBtn = document.getElementById('encryptBtn');
    const decryptBtn = document.getElementById('decryptBtn');
    const encryptedOutput = document.getElementById('encryptedOutput');
    const MAX_FILE_SIZE = 1024 * 1024; // 1MB
    let fileBuffer = null;
    let sensitiveRanges = [];
    let headerRanges = [];

    // Supported file types and their magic numbers
    const fileSignatures = {
      'txt': { signature: null, metadata: parseTextMetadata, sensitive: parseTextSensitive, headers: parseTextHeaders },
      'jpg': { signature: [0xFF, 0xD8], metadata: parseImageMetadata, sensitive: parseImageSensitive, headers: parseImageHeaders },
      'jpeg': { signature: [0xFF, 0xD8], metadata: parseImageMetadata, sensitive: parseImageSensitive, headers: parseImageHeaders },
      'png': { signature: [0x89, 0x50, 0x4E, 0x47], metadata: parseImageMetadata, sensitive: parseImageSensitive, headers: parseImageHeaders },
      'docx': { signature: [0x50, 0x4B, 0x03, 0x04], metadata: parseDocxMetadata, sensitive: parseDocxSensitive, headers: parseDocxHeaders },
      'mp3': { signature: [0x49, 0x44, 0x33], metadata: parseMp3Metadata, sensitive: parseMp m3Sensitive, headers: parseMp3Headers },
      'pdf': { signature: [0x25, 0x50, 0x44, 0x46], metadata: parseGenericMetadata, sensitive: parseGenericSensitive, headers: parsePdfHeaders },
      'mp4': { signature: [0x00, 0x00, 0x00, 0x18, 0x66, 0x74, 0x79, 0x70], metadata: parseGenericMetadata, sensitive: parseGenericSensitive, headers: parseMp4Headers }
    };

    // File input handler
    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      // Validate file size
      if (file.size > MAX_FILE_SIZE) {
        showError(`File size exceeds ${MAX_FILE_SIZE / 1024}KB limit.`);
        return;
      }

      // Read file as array buffer
      const arrayBuffer = await file.arrayBuffer();
      fileBuffer = new Uint8Array(arrayBuffer);

      // Detect file type
      const ext = file.name.split('.').pop().toLowerCase();
      const fileType = fileSignatures[ext] ? ext : 'unknown';
      if (fileType === 'unknown' || !checkFileSignature(fileBuffer, fileSignatures[ext]?.signature)) {
        showError('Unsupported or invalid file format.');
        return;
      }

      // Get sensitive and header ranges
      sensitiveRanges = await fileSignatures[ext].sensitive(file, fileBuffer);
      headerRanges = await fileSignatures[ext].headers(file, fileBuffer);
      // Display graphical view
      drawFileCanvas(fileBuffer, sensitiveRanges, headerRanges);
      // Display hex data with sensitive highlights
      displayHex(fileBuffer, sensitiveRanges);
      // Display metadata
      const metadataText = await fileSignatures[ext].metadata(file, fileBuffer);
      metadata.innerHTML = metadataText;
      // Display binary sample
      displayBinarySample(fileBuffer);
      // Initialize scrubber
      initScrubber(fileBuffer);
      // Clear encryption output
      encryptedOutput.value = '';
      clearError();
    });

    // Canvas click handler
    fileCanvas.addEventListener('click', (e) => {
      const rect = fileCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const byteIndex = Math.floor(x / (fileCanvas.width / fileBuffer.length));
      scrubber.value = byteIndex;
      scrubberPos.textContent = `Position: ${byteIndex}`;
      highlightHexPosition(byteIndex);
      drawFileCanvas(fileBuffer, sensitiveRanges, headerRanges, byteIndex);
    });

    // Save hex changes
    saveHex.addEventListener('click', () => {
      const hex = hexViewer.textContent.replace(/\s/g, '');
      if (!/^[0-9A-Fa-f]*$/.test(hex) || hex.length % 2 !== 0) {
        showError('Invalid hex data.');
        return;
      }
      fileBuffer = new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
      drawFileCanvas(fileBuffer, sensitiveRanges, headerRanges);
      displayHex(fileBuffer, sensitiveRanges);
      clearError();
    });

    // Scrubber handler
    scrubber.addEventListener('input', () => {
      const pos = parseInt(scrubber.value);
      scrubberPos.textContent = `Position: ${pos}`;
      highlightHexPosition(pos);
      drawFileCanvas(fileBuffer, sensitiveRanges, headerRanges, pos);
    });

    // Encryption handler
    encryptBtn.addEventListener('click', () => {
      if (!fileBuffer) {
        showError('No file loaded.');
        return;
      }
      const cipher = cipherSelect.value;
      const key = cipherKey.value;
      if (!key) {
        showError('Encryption key is required.');
        return;
      }
      const encrypted = encryptData(fileBuffer, cipher, key);
      displayEncryptedHex(encrypted);
      clearError();
    });

    // Decryption handler
    decryptBtn.addEventListener('click', () => {
      if (!fileBuffer) {
        showError('No file loaded.');
        return;
      }
      const cipher = cipherSelect.value;
      const key = cipherKey.value;
      if (!key) {
        showError('Decryption key is required.');
        return;
      }
      const decrypted = decryptData(fileBuffer, cipher, key);
      displayEncryptedHex(decrypted);
      clearError();
    });

    // Draw file on canvas
    function drawFileCanvas(buffer, sensitiveRanges, headerRanges, highlightPos = -1) {
      const ctx = fileCanvas.getContext('2d');
      const width = Math.min(800, buffer.length);
      const height = 20;
      fileCanvas.width = width;
      fileCanvas.height = height;
      const pixelWidth = width / buffer.length;

      for (let i = 0; i < buffer.length; i++) {
        let color = 'rgb(200, 200, 200)'; // Unknown/Other (Gray)
        if (headerRanges.some(([start, end]) => i >= start && i <= end)) {
          color = 'rgb(173, 216, 230)'; // File System/Headers (Blue)
        } else if (sensitiveRanges.some(([start, end]) => i >= start && i <= end)) {
          color = 'rgb(255, 255, 224)'; // Metadata (Yellow)
        } else {
          color = 'rgb(144, 238, 144)'; // Content (Green)
        }
        ctx.fillStyle = color;
        ctx.fillRect(i * pixelWidth, 0, pixelWidth, height);
      }

      // Draw highlight for current position
      if (highlightPos >= 0 && highlightPos < buffer.length) {
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 2;
        ctx.strokeRect(highlightPos * pixelWidth, 0, pixelWidth, height);
      }
    }

    // Display hex data with highlights
    function displayHex(buffer, ranges) {
      const hex = Array.from(buffer)
        .map((b, i) => {
          const hexByte = b.toString(16).padStart(2, '0').toUpperCase();
          const isSensitive = ranges.some(([start, end]) => i >= start && i <= end);
          return isSensitive
            ? `<span class="bg-yellow-200" title="Potentially Sensitive Data">${hexByte}</span>`
            : hexByte;
        })
        .join(' ');
      hexViewer.innerHTML = hex;
    }

    // Highlight hex position
    function highlightHexPosition(pos) {
      const hex = hexViewer.textContent.split(' ');
      if (pos < hex.length) {
        hexViewer.focus();
        const range = document.createRange();
        const sel = window.getSelection();
        const span = hexViewer.childNodes[pos] || hexViewer.childNodes[0];
        range.selectNodeContents(span);
        sel.removeAllRanges();
        sel.addRange(range);
      }
    }

    // Initialize scrubber
    function initScrubber(buffer) {
      scrubber.max = buffer.length - 1;
      scrubber.value = 0;
      scrubberPos.textContent = `Position: 0`;
    }

    // Display binary sample
    function displayBinarySample(buffer) {
      const sample = Array.from(buffer.slice(0, 256))
        .map(b => b.toString(2).padStart(8, '0'))
        .join(' ');
      binaryOutput.textContent = sample || 'No binary data available.';
    }

    // Check file signature
    function checkFileSignature(buffer, signature) {
      if (!signature) return true;
      return signature.every((byte, i) => buffer[i] === byte);
    }

    // Parse text metadata
    function parseTextMetadata(file) {
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = () => {
          resolve(`File Name: ⚠️ ${file.name}<br>Size: ${file.size} bytes<br>Type: text/plain<br>Sample Content: ${reader.result.slice(0, 100)}...`);
        };
        reader.readAsText(file);
      });
    }

    // Parse text sensitive ranges
    function parseTextSensitive(file) {
      return Promise.resolve([]); // No specific sensitive ranges
    }

    // Parse text headers
    function parseTextHeaders(file) {
      return Promise.resolve([]); // No headers for text
    }

    // Parse image metadata
    function parseImageMetadata(file) {
      return new Promise((resolve) => {
        window.EXIF.getData(file, function() {
          const exifData = window.EXIF.getAllTags(this);
          const metadata = [`File Name: ⚠️ ${file.name}`, `Size: ${file.size} bytes`, `Type: ${file.type}`];
          for (let tag in exifData) {
            const isSensitive = ['GPSLatitude', 'GPSLongitude', 'DateTime', 'Model'].includes(tag);
            metadata.push(`${isSensitive ? '⚠️ ' : ''}${tag}: ${exifData[tagbq]}`);
          }
          resolve(metadata.join('<br>') || 'No EXIF data available.');
        });
      });
    }

    // Parse image sensitive ranges
    function parseImageSensitive(file, buffer) {
      return new Promise((resolve) => {
        window.EXIF.getData(file, function() {
          const ranges = [];
          for (let i = 0; i < buffer.length - 1; i++) {
            if (buffer[i] === 0xFF && buffer[i + 1] === 0xE1) {
              ranges.push([i, i + 100]); // Approximate EXIF range
              break;
            }
          }
          resolve(ranges);
        });
      });
    }

    // Parse image headers
    function parseImageHeaders(file, buffer) {
      return Promise.resolve([[0, 8]]); // First 8 bytes for magic numbers
    }

    // Parse docx metadata
    async function parseDocxMetadata(file, buffer) {
      try {
        const zip = await JSZip.loadAsync(buffer);
        const docProps = await zip.file('docProps/core.xml')?.async('string');
        if (docProps) {
          const parser = new DOMParser();
          const xml = parser.parseFromString(docProps, 'application/xml');
          const props = {
            creator: xml.querySelector('creator')?.textContent,
            lastModifiedBy: xml.querySelector('lastModifiedBy')?.textContent,
            created: xml.querySelector('created')?.textContent,
            modified: xml.querySelector('modified')?.textContent
          };
          return `File Name: ⚠️ ${file.name}<br>Size: ${file.size} bytes<br>Type: ${file.type}<br>Creator: ⚠️ ${props.creator || 'N/A'}<br>Last Modified By: ⚠️ ${props.lastModifiedBy || 'N/A'}<br>Created: ${props.created || 'N/A'}<br>Modified: ${props.modified || 'N/A'}`;
        }
        return `File Name: ⚠️ ${file.name}<br>Size: ${file.size} bytes<br>Type: ${file.type}<br>No detailed metadata available.`;
      } catch (e) {
        return `Error parsing docx metadata: ${e.message}`;
      }
    }

    // Parse docx sensitive ranges
    async function parseDocxSensitive(file, buffer) {
      try {
        const zip = await JSZip.loadAsync(buffer);
        const docProps = await zip.file('docProps/core.xml')?.async('string');
        if (docProps) {
          return [[0, 500]]; // First 500 bytes for ZIP headers and metadata
        }
        return [];
      } catch (e) {
        return [];
      }
    }

    // Parse docx headers
    async function parseDocxHeaders(file, buffer) {
      return [[0, 30]]; // ZIP file header
    }

    // Parse mp3 metadata
    function parseMp3Metadata(file, buffer) {
      const id3 = buffer.slice(0, 128);
      if (id3[0] === 0x54 && id3[1] === 0x41 && id3[2] === 0x47) {
        const title = String.fromCharCode(...id3.slice(3, 33)).trim();
        const artist = String.fromCharCode(...id3.slice(33, 63)).trim();
        const album = String.fromCharCode(...id3.slice(63, 93)).trim();
        return `File Name: ⚠️ ${file.name}<br>Size: ${file.size} bytes<br>Type: ${file.type}<br>Title: ⚠️ ${title || 'N/A'}<br>Artist: ⚠️ ${artist || 'N/A'}<br>Album: ⚠️ ${album || 'N/A'}`;
      }
      return `File Name: ⚠️ ${file.name}<br>Size: ${file.size} bytes<br>Type: ${file.type}<br>No ID3v1 metadata found.`;
    }

    // Parse mp3 sensitive ranges
    function parseMp3Sensitive(file, buffer) {
      if (buffer[0] === 0x49 && buffer[1] === 0x44 && buffer[2] === 0x33) {
        return [[0, 128]]; // ID3v1 tag at start
      }
      return [];
    }

    // Parse mp3 headers
    function parseMp3Headers(file, buffer) {
      return [[0, 10]]; // ID3 header
    }

    // Parse generic metadata
    function parseGenericMetadata(file) {
      return `File Name: ⚠️ ${file.name}<br>Size: ${file.size} bytes<br>Type: ${file.type}<br>No specific metadata parser available.`;
    }

    // Parse generic sensitive ranges
    function parseGenericSensitive(file) {
      return Promise.resolve([]);
    }

    // Parse PDF headers
    function parsePdfHeaders(file, buffer) {
      return [[0, 8]]; // PDF magic number
    }

    // Parse MP4 headers
    function parseMp4Headers(file, buffer) {
      return [[0, 8]]; // MP4 ftyp box
    }

    // Encrypt data
    function encryptData(buffer, cipher, key) {
      if (cipher === 'caesar') {
        const shift = parseInt(key) || 3;
        return Array.from(buffer).map(b => (b + shift) % 256);
      } else if (cipher === 'aes') {
        const text = String.fromCharCode(...buffer);
        const encrypted = CryptoJS.AES.encrypt(text, key).toString();
        return new TextEncoder().encode(encrypted);
      } else if (cipher === 'xor') {
        const keyByte = parseInt(key) || 0xFF;
        return Array.from(buffer).map(b => b ^ keyByte);
      }
      return buffer;
    }

    // Decrypt data
    function decryptData(buffer, cipher, key) {
      if (cipher === 'caesar') {
        const shift = parseInt(key) || 3;
        return Array.from(buffer).map(b => (b - shift + 256) % 256);
      } else if (cipher === 'aes') {
        try {
          const text = String.fromCharCode(...buffer);
          const decrypted = CryptoJS.AES.decrypt(text, key).toString(CryptoJS.enc.Utf8);
          return new TextEncoder().encode(decrypted);
        } catch (e) {
          showError('Decryption failed. Invalid key or data.');
          return buffer;
        }
      } else if (cipher === 'xor') {
        const keyByte = parseInt(key) || 0xFF;
        return Array.from(buffer).map(b => b ^ keyByte);
      }
      return buffer;
    }

    // Display encrypted hex
    function displayEncryptedHex(buffer) {
      const hex = Array.from(buffer)
        .map(b => b.toString(16).padStart(2, '0').toUpperCase())
        .join(' ');
      encryptedOutput.value = hex;
    }

    // Show error
    function showError(msg) {
      error.textContent = msg;
      error.classList.remove('hidden');
    }

    // Clear error
    function clearError() {
      error.textContent = '';
      error.classList.add('hidden');
    }
  </script>
</body>
</html>
